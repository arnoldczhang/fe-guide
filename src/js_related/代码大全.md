# 代码大全

## 目录
<details>
<summary>展开更多</summary>

* [`何为软件开发`](#何为软件开发)
* [`前期准备`](#前期准备)
* [`构建决策`](#构建决策)
* [`构建中的设计`](#构建中的设计)
* [`可以工作的类`](#可以工作的类)
* [`高质量子程序`](#高质量子程序)
* [`变量命名`](#变量命名)
* [`科普内容`](#科普内容)

</details>

## 何为软件开发

### 解释
* 定义问题
* 需求分析
* （初步）规划构建
* 软件架构（高层架构）设计
* 详细设计
* 编码调试
* 单元测试
* 集成测试
* 集成
* 系统测试
* 维护保障

### 项目生长
增量式、迭代的、自适应的
* 初期要搭建最简单、牢固的骨架，用于支撑将来要开发的真实需求
* 逐步充实骨架，一次新增一部分，直至填满骨架
* 得到阶段性成果，而不用给出过多的承诺

## 前期准备

### 需要准备的先决条件
* 项目需求不明确
* 设计复杂
* 未知领域

### 如何应对需求变更
* 评估需求质量
  * 功能性
    * 全部输入输出
    * 数据格式
    * 用户反馈
  * 非功能性
    * 响应时间
    * 安全级别
    * 降级策略
    * 成功失败定义
    * 可维护性
    * 需求完备性（未来可能的改动点）
* 确保周知变更代价
* 设定需求变更周期
* 演进交付，做少量改动，同步到用户，获知反馈，持续演进
* 回绝
* 考虑项目商业价值

### 架构组成部分
* 主要构造块
  * 其职责、对应于哪个需求、构造块之间的通信规则
  * 记录曾考虑过的其他设计方案，给出选择当前架构的理由
* 业务规则
  * 如果依赖于特定业务规则，需要明确记录其对架构的影响
* 资源管理
  * 内存、线程、网络连接等
* 用户界面
* 安全性
  * 处理用户输入、cookies、缓存数据等
* 性能
  * 明确速度、内存、成本之间的优先级
  * 明确能否达成性能目标的风险
  * 如果某些部分使用了特定算法也要明确清楚
* 可扩展性
  * 数据量级提升，功能扩展等
* 互用性
  * 与其他软件公用资源
* 国际化
  * 文本存储方式（单独类、配置文件、硬编码等），并给出理由
* I/O
  * 定义读取策略
  * 明确在哪一层检测I/O错误
* 异常处理
  * 发现方式 - 纠错or检测
  * 检测方式 - 主动or被动
  * 传播方式 - 捕获即抛or处理完成再抛
  * 处理规则 - 消息体格式、内容
  * 处理方式 - 何时抛出、如何记录、内容描述
  * 处理位置 - 通用类or随机
* 降级
  * 回滚
  * 降级到兜底方法
  * 表决算法（多个方法同时计算，根据均值等标准选择结果）
  * 使用默认值
* 可行性
* 过度工程
  * 保证各个模块都具有合理的健壮性
* 复用或造轮子
* 总体质量
  * 能准确描述各个主要决策的动机
  * 避免过度架构
  * 是否解决全部需求
  * 无关乎编程语言

### 前期准备时间
* 取决于项目规模，10% - 30%
* 为新挑战预留更多时间
* 如果不确定因素过大，要将需求分析作为单独项目处理

## 构建决策
* 编程约定
  * 注释、命名、代码格式
  * 在一种语言上编程vs深入一种语言编程
* 团队约定
  * 代码check in之前的集成工序
  * 结对、独立编程？
* 质量保证
  * 单元测试
  * 单步调试代码流程
  * 集成测试
  * code review
* 工具
  * 版本控制工具
  * 限定语言、框架版本
  * 能否使用非标准语法特性？
  * 调试器、测试框架

## 构建中的设计

### 关键设计概念
* 最小的复杂度
* 易维护
* 低耦合
* 可扩展
* 复用性
* 高扇入（大量类调用到一个公共类）
* 低扇出（一个类不能大量（7个）使用其他类）
* 可移植
* 精简（无冗余代码）
* 层次性（能在任意层次上单独观察）
  - 例：坏的旧的代码，需要在上面建一个交互层，隐藏底层复杂逻辑，之后如果重构，只需修改交互层代码即可

### 设计层次
* 系统
  - node_modules
* 子系统
  - export default、export
  - 子系统之间避免通信
  - 避免环引用
* 类
  - 运行过程中，创建对象
* 子程序
  - 私有方法、公有方法等
* 子程序内部

### 面向对象设计
* 方法、数据
* 可对其他对象的操作
* 可被其他对象的操作
* 公用、私有数据
* 公开的接口

#### 抽象VS封装
抽象
* 关注某一概念的同时忽略其中细节的能力
封装（信息隐藏）
* 通过隐藏细节来简化复杂概念
  - 隐藏复杂度
  - 隐藏变化源

### 如何设计容易变更的内容

#### 具体做法
* 准备一份潜在变化的清单
* 将列出的类单独划分，或者都划在一个类
* 定义类的对外接口，将变化隔离在类内部

#### 主要包括
* 业务规则
* 对硬件（外部）依赖
* 非标准特性、兼容处理
* 老旧代码
* 状态变量
  - 枚举型
  - 通过访问器修改值

### 如何设计松散耦合

#### 标准
* 连接规模（方法、传参数量）
* 可见性（连接是否明显）
* 灵活性（降低其他系统接入成本）

#### 常见种类
* 简单数据类型 - 推荐
* 简单对象 - 推荐
* 对象参数（object1里引用了object2） - 推荐
* 语义（标志位、全局变量更改顺序、初始化调用次序等） - 不推荐

### 其他设计方法
* 高内聚（包含一组密切相关的功能的类）
* 分层结构（轮廓-》细节）
* 分配职责
* 为测试而设计

### 设计实践

#### 自上而下
* 大事物 -》小组件
* 较简单
* 推迟构建的细节

#### 自下而上
* 较早找出所需功能，推算出更高层次的
* 如果之前有类似的可以考虑复用

### 记录设计成果
80%时间用于调研各种设计方案，20%时间写文档
* 代码注释里
* wiki
* 邮件（抄送项目组）
* UML

## 可以工作的类

### 抽象数据类型（ADT）
对数据操作的集合，类似getter、setter
* 隐藏实现细节，暴露操作接口
* 约束改动范围
* 提升可读性（自我说明性）

### 良好的类接口

#### 抽象
* 保持一致的抽象层次
```js
class Employer {
  addEmployer() {

  }

  removeEmployer() {

  }

  // ...
}
```
* 提供成对的接口
* 类数据与类接口必须强相关
* 不要对类接口的使用者做出任何假设
* 谨防修改时，添加与类接口抽象程度不一致的成员
* 内聚性

#### 封装
* 尽可能限制类和成员的可访问性
* 不要公开成员数据
* 不要对类接口的使用者做出任何假设
* 避免使用[友元类](https://baike.baidu.com/item/%E5%8F%8B%E5%85%83%E7%B1%BB/518734)
* 代码可读性

### 设计实现

#### 包含
* 类方法的扩充
* 如果只是想使用类的具体实现，请用包含

#### 继承
* 派生类能完全遵守基类的接口契约
* 派生类是个更特殊的基类，否则不应该继承
* 避免派生类的成员函数和基类不可覆盖的成员函数重名
* 单例不该创建类，而是对象
* 只有一个派生类的基类，该怀疑
* 派生类覆盖基类的某个类方法，但其中没有任何操作，考虑用包含解决
```js
class Claw {
  // ...
}
class Cat {
  constructor(...args) {
    this.claw = new Claw(...args);
  }
  // ...
}
```
* 多态代替类型检查

#### 成员函数和数据
* 禁止调用其他类的子类中的类方法
* 尽量减少调用的其他类之间的交互

#### 构造函数
* 类数据尽量在构造函数初始化
* 强行要用类实现单例的话， 提供`getInstance()`方法即可

### 创建类的原因
* 降低/隐藏复杂度
* 隐藏细节
* 限制变化范围

#### 应避免的类
* 万能类
* 无用类
* 动词命名的类

## 高质量子程序

### 子程序目的
* 复用
* 隐藏细节、全局变量

## 变量命名

### 类型
- 临时变量、循环变量
- 常量
- bool变量
- 正常变量

### 长度
8-20

### 限定词
min, max, average, sum, total

### 缩写规范
- 一致性（所有文件）
- 避免一个单词删一个字符的方式
- 缩写后能读出来
- 同义不同词（解决冲突）
- 缩写对照表

#### 顺序
通常加在名字结束位置

#### 命名举例
distanceMin, expenseTotal

#### 例外
num
- 开始位置，表示总数，比如：numCustomers
- 结束位置，表示下标，比如：customerNum
- 最好还是避开num

### bool变量
结果后置，某件事 + done/found/success/done/fail

### 使用命名规范

#### 时机
- 多人合作
- 交接
- 项目规模

#### 考虑点
- 变量内容（驼峰、xx_xx_xx）
- 命名种类（参考上面的【类型】）
- 变量作用域（全局、临时）

## 科普内容

### 传统序列式开发

#### 特点
1. 将项目的生命周期明确地划分为几个阶段，完成一个阶段才进入下一个阶段。
2. 在项目初期希望细化所有的需求，并希望在一个阶段将需求固定后不再改变。
3. 在需求定义完毕后，在编码之前进行较详细的预 先设计，完成所有或者大部分的设计工作才开始编码。
4. 每一个阶段需要产出大量的文档作为下一阶段的输入。

#### 缺点
1. 阶段性需求固化，不太现实
2. 研发与用户间隔阂，导致理解有偏差
3. 项目周期如果较长，项目初期很难细化完整设计

### 迭代式（敏捷）开发

#### 特点
1. 项目初期定义好产品设想以及功能列表，并对产品功能排好优先级
2. 根据优先级，挑选一小部分需求进行细化，项目初始阶段通常挑选高风险的、决定核心架构的、业务性质重要的功能需求来细化。
3. 针对细化的一部分需求进行设计和编码，得到可运行的软件然后交付给用户，或给用户演示并收集反馈。
4. 根据用户的反馈修改需求，并提交新版本的软件给用户，直到用户满意。
5. 重复 2~4，直到完成所有的功能。每次迭代大约需要数周，不宜太长，越短越好，每个项目可能要经历十多次迭代





