## indexOf VS search
- search:默认处理正则，比如'aaa\n'.search('.')，是0，因为/./
- indexOf:处理字符串，同是字符串，略快

## 正则

### 特殊用法
匹配所有 - [^]

### 转义字符
- * . ? + $ ^ [ ] ( ) { } | \ /

## 0.1 + 0.2 !== 0.3
- js中的数字都是用IEEE 754 标准的双精度浮点数表示
- IEEE双精度格式具有53 位有效数字精度(包含1位符号位)，并总共占用64 位
- 计算机中存储小数是先转换成二进制进行存储
- Number.MAX_SAFE_INTEGER 2的53次方 - 1
例：
```js
// 9007199254740991
// 
// (0.1)10 => (0.00011001100110011001(1001循环)...)2
// (0.2)10 => (0.00110011001100110011(0011循环)...)2
```

## 泛用型isObject
- 类似new String('aa')仍不算object
```js
function isProxyable(value) {
  if (!value) return false;
  if (typeof value !== "object") return false;
  if (Array.isArray(value)) return true;
  const proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype;
};
```

## ajax

### readystate
- 0: 请求未初始化（还没有调用 open()）。
- 1: 请求已经建立，但是还没有发送（还没有调用 send()）。
- 2: 请求已发送，正在处理中（通常现在可以从响应中获取内容头）。
- 3: 请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。
- 4: 响应已完成；您可以获取并使用服务器的响应了。

## Object.getOwnPropertyDescriptor
```js
var obj = {};
Object.defineProperty(obj, aa, {
  get() {/*...*/},
  set() {/*...*/},
});

Object.getOwnPropertyDescriptor(obj);
/*
  {
    get(){},
    set(){},
    configurable: true,
    enumerable: true,
  }
*/
```

## JSON.stringify

### toJSON
- 如果对象中定义了toJSON() 方法，stringify会首先调用该方法，再用它的返回 值来进行序列化
```js
var obj = {
  toJSON() {
    return 'aaa';
  },
};
```

### 支持的数据类型
由于JSON是通用文本格式，和语言无关，所以无法针对语言的特定数据类型做转换
- String
- Number
- Null
- Boolean

## valueOf VS toString
- 类型转换时，优先调用valueOf()方法，然后通过toString抽象操作将返回值转换为字符串
```js
function Foo(n) {
  this.number = n;
}

Foo.prototype.valueOf = function() {
  return 123;
};

var obj = new Foo;
obj + 1; // 此时输出124

Foo.prototype.valueOf = function() {
  return 321;
};

obj + 1; // 此时输出322
```

## this
- 函数在new中调用(new绑定)的话，this绑定的是新创建的对象。
```js
var bar = new foo();
```

- 函数是否通过call、apply(显式绑定)或者硬绑定调用，this绑定的是指定的对象。
```js
var bar = foo.call(obj2);
var bar2 = foo.apply(obj2);
var bar3 = foo.bind(obj2);
```

- 函数是否在某个上下文对象中调用(隐式绑定)，this 绑定的是那个上下文对象。
```js
var bar = obj1.foo();
```

- 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。
```js
var bar = foo();
```

## this显式绑定
```js
class MeowctComponent {
  constructor() {
    this.paw = document.getElementById('button');
  }

  meow() {
    console.info('🐱 on this: ', this.paw);
  }
}
const cat = new MeowctComponent();

// 方式1：箭头函数
cat.paw.addEventListener('click', () => cat.meow());
// 方式2：bind
cat.paw.addEventListener('click', cat.meow.bind(cat));
// 方式3：绑定操作符::（提案）
cat.paw.addEventListener('click', ::cat.meow);
```

## new关键字
- 参考ecma262-12.3.3
- 创建一个新的对象，这个对象的类型是object
- 设置这个新的对象的内部、可访问性和[[Prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的
- 执行[[Construct]]，当this关键字被提及的时候，使用新创建的对象的属性
- 返回新创建的对象（除非构造方法中返回的是‘无原型’）

## 创建对象
```js
var atom = {/* ... */};
var atom = Object.create(null);
var atom = new Foo;
var atom = Foo.call(/* ... */);
var atom = Object.setPrototypeOf(new Object, null);
```

## +
- 操作数是string，做拼接，否则做相加；
- 操作数是object，做toPrimitive（valueOf或toString），再按（1）判断；

## == VS ===
-  == 允许在相等比较中进行强制类型转换，而 === 不允许。

## 字符串和数字之间的相等比较
- 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。 
- 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。
- 否则返回 ToBoolean(x) == ToBoolean(y)的结果。

## 对象和非对象之间的相等比较
- ToPromitive默认转数字；
- 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；
- 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果；

## Object.preventExtensions、Object.seal、Object.freeze
- http://www.cnblogs.com/snandy/p/5278474.html

## 对象删除不需要的属性
```js
const obj = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
};

const {
  a,
  b,
  ...cleanObject,
} = obj;

console.log(cleanObject);
```

## 合并对象
```js
const obj = {
  a: 1,
  b: 2,
};

const obj2 = {
  c: 3,
  d: 4,
};

const obj3 = {...obj, ...obj2};
console.log(obj3);
```

## Set数组去重
let arr = [1, 1, 2, 2, 3, 3];
let deduped = [...new Set(arr)];

## Promise.all
- 只要一个结果是reject就进error
```js
async function getFullPost() {
  return await Promise.all([
    fetch('/aa'),
    fetch('/bb')
  ]);
};

const [aa, bb] = getFullPost();
```

## 字符串转数组
```js
[...`${str}`]
```

## 扁平化1层数组 flatten(array, 1)
```js
const arr = [11, [22, 33], [44, 55], 66];
const flatArr = [].concat(...arr);
```

## async/await VS generator
- async是Generator函数的语法糖。
- async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await
```js
function *foo() {
  yield 1;
  yield 2;
  yield 3;
};

var f = foo();
f.next();
// { value: 1, done: false }
// ...
```

## exec VS match
- exec会带lastIndex，match不会
例：正则递归
```js
var str = 'abc';
var reg = /\w/g;
var result;
while (result = reg.exec(str)) {
  console.log(result);
}
```

## 设置Error的stack层数
Error.stackTraceLimit = Infinity

## 函数调用模式
- 函数调用
  - foo.getName()
- 方法调用
  - getName()
- .call()
- .apply()

## iterator
- 具有Symbol.iterator属性，即是iterable

### 原生具备Iterator接口的数据结构
- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象
```js
var arr = [];
var iterator = arr[Symbol.iterator](); // { next () { ... } }
```

## 反模式
- 在全局上下文中定义大量的变量污染全局命名空间。
- 向setTimeout或setInterval传递字符串，无意中触发eval( )的内部使用。
- 修改Object类的原型
- 以内联形式使用Javascript，它是不可改变的。
- 在使用document.createElement等原生DOM方法更适合的情况下使用document.write

## 类型语言
- 静态类型语言：在编译时期就检查数据类型的，所以必须在声明变量的时候指定数据类型，否则编译会不通过
- 强类型语言：变量的数据类型一旦确定下来，就不能改变了，除非经过强制类型转换

## fetch VS XMLHttpRequest
相比XMLHttpRequest，fetch可对请求做更多控制
- credentials
- mode
- cache
- redirect
- referrer
- integrity

### credentials
控制请求是否带上 cookie 等机密信息

fetch
- omit: 请求不带任何 cookie
- same-origin: 同域请求会带上 cookie
- include: 无论是否跨域都会带上 cookie

XMLHttpRequest (withCredentials)
- true: 大致对应上面的 include，MDN 上描述此 flag 不止控制 cookie 还控制 authorization headers 或者 TLS client certificates。
- false: 大致对应上面的 omit，MDN 上描述为 false 时还控制跨域请求的 response 不能设置 cookie。

### mode
设置请求方式的阻止跨域标志位

fetch
- same-origin
- no-cors
- cors
- navigate

## 递归
for (var f = 1; number > 1; f *= number--)

- - -

## 其他
- 在 ES6 中，如果参数被省略或者值为 undefined，则取该参数的默认值
- 函数声明不可以省略函数名
- localstorage限制：pc端：5-10M，移动端：2.5M
- 控制反转是思想，依赖注入是具体实现
