# 设计模式

[设计模式](https://www.w3cschool.cn/zobyhd/pyunfozt.html)

## 目录
<details>
<summary>展开更多</summary>

* [`工厂模式`](#工厂模式)
* [`单例模式`](#单例模式)
* [`原型模式`](#原型模式)
* [`观察者模式`](#观察者模式)

</details>

---

## 工厂模式
>
> 1. 工厂函数提供一个创建对象的公共接口
> 2. 根据入参的不同，创建不同类型的对象

```js
function Car(options) {
  this.doors = options.doors || 4;
};

function Truck(options) {
  this.doors = options.doors || 2;
};

function VehicleFactory(klass) {
  this.klass = klass;
};

VehicleFactory.prototype.createVehicle = function createVehicle(options) {
  return new this.klass(options);
};

// carFactory
const carFactory = new VehicleFactory(Car);

// truckFactory
const truckFactory = new VehicleFactory(Truck);

// car instance
const newCar = carFactory.createVehicle({
  // ...
});

// truck instance
const newTruck = carFactory.createVehicle({
  // ...
});
```

---

## 单例模式
>
> 1. 限制一个类只能有一个实例化对象
> 2. 通常暴露getInstance方法用于实例化对象

```js
const mySingleton = (function() {
  let singleton;

  function init(options) {
    if (singleton) {
      return singleton;
    }

    singleton = {
      name: options.name,
    };
    return singleton;
  };

  return {
    getInstance(options) {
      const instance = init(options);
      return instance;
    },
  };
} ());

const me = mySingleton.getInstance();
const you = mySingleton.getInstance();
console.log(me === you); // true
```

---

## 原型模式
>
> 1. 动态改变对象的__proto__，比如Object.create
> 2. 动态改变类的prototype，基于类生产的对象的__proto__，都指向同一个原型

### Object.create
```js
var vehicle = {
    getModel: function () {
        console.log('车辆的模具是：' + this.model);
    }
};

var car = Object.create(vehicle, {
  id: {
    value: MY_GLOBAL.nextId(),
    enumerable: true // 默认writable:false, configurable:false
  },
  model: {
    value: '福特',
    enumerable: true
  },
});
```

### prototype
```js
var proto = {
  init(model) {
    this.model = model;
  },
};

function vehicle(model) {
  function F() {};
  F.prototype = proto;
  var f = new F();
  f.init(model);
  return f;
};

//
var car = vehicle('mazda');
```

---

## 观察者模式




---
