# 设计数据密集型应用

## 基本概念

### 事实表

> 即大宽表，上百列，几十亿条数据，列存储维表id



### 维表

> 和事实表的列对应，几十列，上百万条数据，主要存储维度详情



### 星型模式

> 事实表居中，对应周围维度表



### OLTP和OLAP

> 在线事务处理(**OLTP, OnLine Transaction Processing**)
>
> 在线分析处理(**OLAP, OnLine Analytice Processing**)

![oltp和olap](./oltp和olap.jpeg)



### 物化视图

> 1. 查询结果的非规范化副本，写入磁盘，由数据库自动完成
> 2. 会导致数据更新成本更高（原表 + 物化视图）

---

## 分布式

### 数据复制

![数据复制&分区](./数据复制&分区.jpeg)



**变更复制算法**

- 单领导者
- 多领导者
- 无领导者



#### 1. 主从关系-单领导者

> 领导者（主库master）仅负责写，写入后，通知从库更新数据
>
> 跟随者（从库slave）仅负责读

**特点：强一致性，弱容灾**



#### 2. 同步复制vs异步复制

**同步复制**

优点：数据保证强一致性

缺点：一旦从库异常（奔溃、断网），主库将阻止所有写入直至从库恢复



**异步复制**

优点：从库异常，不影响主库写入

缺点：数据弱一致性



**半同步**

> 1个同步复制从库 + n个异步复制从库

优点：

- 至少能保证两个节点（主库、同步从库）拥有最新数据副本
- 如果同步从库异常，会自动使一个异步从库变同步



**全异步**

> 主流做法

优点：即使所有从库落后主库版本，主库都能正常写入



**从库失效**

追赶恢复，通过排查发生故障前最后一个事务，应用后续所有变更直至追上主库



**主库失效**

- 确认失效（定时检测心跳）
- 选举新主库（通常选具有最新副本的从库，减小损失）
- 重新配置以启用新主库（其他从库认同这个“新话事人”，包括失效的主库）



#### 3. 语句复制vs行复制

- 通常情况，从库直接同步主库的语句（比如Insert、Update等）

- 有些场景会出现不确定写入（比如Now()、rand()、自增索引），数据库会改用行复制



#### 4. 最终一致性

- **写后读**，用户可修改内容从主库读，其他从从库读
- 检测最晚更新时间，比如1分钟内，主库读，否则从库读
- 多数据中心，任何需要领导者提供的服务，都需经过其所在数据中心
- 多设备多网络环境（wifi、蜂窝）同账号，应该读同数据中心
- **单调读**，保证单个用户都从单个从库读数据，避免“时光倒流”（如果从库异常还是要降级）



#### 5. 主从关系-多领导者

> 任意领导者接受写入后，同步数据更新给其他领导者，以及跟随者

- 多数据中心，多主库
- 如何处理写入冲突
- 如何保证从库一致性

**特点：弱一致性，强容灾**



**最后写入为准**

优点：每次写入附加时间戳，当并发写入时，最近一次生效，丢弃之前的，保证最终值的一致性

缺点：丢弃的值没有持久化；非并发写入也可能被丢弃



#### 6. 主从关系-无领导者

> 节点接受任意写入，并支持任意读取

**特点：弱一致性，强容灾**



**版本向量**

> 每个数据库副本的版本号集合

客户端读取和写入，都携带版本向量，数据库可由此判断，是覆盖写入还是并发写入

---

### 数据分区

> 大型数据库分解成小型数据库的方式



- 一个节点可以含多个分区
- 分区副本可以在多个节点上
- 领导者也可以是跟随者

![分区](./分区.jpeg)



#### 散列分区

> 为每个分区指定散列范围，对写入数据的key做散列处理，并落到对应分区，最终达到数据的均匀分布

