# 基本常识

## 目录
<details>
<summary>展开更多</summary>

* [`Symbol`](#Symbol)
* [`new`](#new)
* [`String`](#String)
* [`JSON`](#JSON)
* [`Object`](#Object)
* [`Number`](#Number)
* [`this`](#this)
* [`ajax`](#ajax)
* [`Array`](#Array)
* [`Promise`](#Promise)
* [`iterator`](#iterator)
* [`cookie`](#cookie)
* [`其他`](#其他)
* [`反模式`](#反模式)
* [`递归`](#递归)
* [`字节`](#字节)

</details>

## String

### indexOf VS search
- search:默认处理正则，比如'aaa\n'.search('.')，是0，因为/./
- indexOf:处理字符串，同是字符串，略快

### valueOf VS toString
- 类型转换时，优先调用valueOf()方法，然后通过toString抽象操作将返回值转换为字符串
```js
function Foo(n) {
  this.number = n;
}

Foo.prototype.valueOf = function() {
  return 123;
};

var obj = new Foo;
obj + 1; // 此时输出124

Foo.prototype.valueOf = function() {
  return 321;
};

obj + 1; // 此时输出322
```

### +
- 操作数是string，做拼接，否则做相加；
- 操作数是object，做toPrimitive（valueOf或toString），再按（1）判断；

### == VS ===
-  == 允许在相等比较中进行强制类型转换，而 === 不允许。

### 字符串和数字之间的相等比较
- 如果 Type(x) 是数字，Type(y) 是字符串，则返回 x == ToNumber(y) 的结果。 
- 如果 Type(x) 是字符串，Type(y) 是数字，则返回 ToNumber(x) == y 的结果。
- 否则返回 ToBoolean(x) == ToBoolean(y)的结果。

### 对象和非对象之间的相等比较
- ToPromitive默认转数字；
- 如果 Type(x) 是字符串或数字，Type(y) 是对象，则返回 x == ToPrimitive(y) 的结果；
- 如果 Type(x) 是对象，Type(y) 是字符串或数字，则返回 ToPromitive(x) == y 的结果；

## regexp

### 特殊用法
匹配所有 - [^]

### 转义字符
- * . ? + $ ^ [ ] ( ) { } | \ /

### exec VS match
- exec会带lastIndex，match不会
例：正则递归
```js
var str = 'abc';
var reg = /\w/g;
var result;
while (result = reg.exec(str)) {
  console.log(result);
}
```

## Number

### 0.1 + 0.2 !== 0.3
- js中的数字都是用IEEE 754 标准的双精度浮点数表示
- IEEE双精度格式具有53 位有效数字精度(包含1位符号位)，并总共占用64 位
- 计算机中存储小数是先转换成二进制进行存储
- Number.MAX_SAFE_INTEGER 2的53次方 - 1
例：
```js
// 9007199254740991
// 
// (0.1)10 => (0.00011001100110011001(1001循环)...)2
// (0.2)10 => (0.00110011001100110011(0011循环)...)2
```

## 泛用型isObject
- 类似new String('aa')仍不算object
```js
function isProxyable(value) {
  if (!value) return false;
  if (typeof value !== "object") return false;
  if (Array.isArray(value)) return true;
  const proto = Object.getPrototypeOf(value);
  return proto === null || proto === Object.prototype;
};
```

## ajax

### readystate
- 0: 请求未初始化（还没有调用 open()）。
- 1: 请求已经建立，但是还没有发送（还没有调用 send()）。
- 2: 请求已发送，正在处理中（通常现在可以从响应中获取内容头）。
- 3: 请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。
- 4: 响应已完成；您可以获取并使用服务器的响应了。

## Object.getOwnPropertyDescriptor
```js
var obj = {};
Object.defineProperty(obj, aa, {
  get() {/*...*/},
  set() {/*...*/},
});

Object.getOwnPropertyDescriptor(obj);
/*
  {
    get(){},
    set(){},
    configurable: true,
    enumerable: true,
  }
*/
```

### fetch VS XMLHttpRequest
相比XMLHttpRequest，fetch可对请求做更多控制
- credentials
- mode
- cache
- redirect
- referrer
- integrity

#### credentials
控制请求是否带上 cookie 等机密信息

fetch
- omit: 请求不带任何 cookie
- same-origin: 同域请求会带上 cookie
- include: 无论是否跨域都会带上 cookie

XMLHttpRequest (withCredentials)
- true: 大致对应上面的 include，MDN 上描述此 flag 不止控制 cookie 还控制 authorization headers 或者 TLS client certificates。
- false: 大致对应上面的 omit，MDN 上描述为 false 时还控制跨域请求的 response 不能设置 cookie。

#### mode
设置请求方式的阻止跨域标志位

fetch
- same-origin
- no-cors
- cors
- navigate

## JSON

### toJSON
- 如果对象中定义了toJSON() 方法，stringify会首先调用该方法，再用它的返回 值来进行序列化
```js
var obj = {
  toJSON() {
    return 'aaa';
  },
};
```

### 支持的数据类型
由于JSON是通用文本格式，和语言无关，所以无法针对语言的特定数据类型做转换
- String
- Number
- Null
- Boolean

## this
- 函数在new中调用(new绑定)的话，this绑定的是新创建的对象。
```js
var bar = new foo();
```

- 函数是否通过call、apply(显式绑定)或者硬绑定调用，this绑定的是指定的对象。
```js
var bar = foo.call(obj2);
var bar2 = foo.apply(obj2);
var bar3 = foo.bind(obj2);
```

- 函数是否在某个上下文对象中调用(隐式绑定)，this 绑定的是那个上下文对象。
```js
var bar = obj1.foo();
```

- 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。
```js
var bar = foo();
```

### this显式绑定
```js
class MeowctComponent {
  constructor() {
    this.paw = document.getElementById('button');
  }

  meow() {
    console.info('🐱 on this: ', this.paw);
  }
}
const cat = new MeowctComponent();

// 方式1：箭头函数
cat.paw.addEventListener('click', () => cat.meow());
// 方式2：bind
cat.paw.addEventListener('click', cat.meow.bind(cat));
// 方式3：绑定操作符::（提案）
cat.paw.addEventListener('click', ::cat.meow);
```

## new

### new关键字
- 参考ecma262-12.3.3
- 创建一个新的对象，这个对象的类型是object
- 设置这个新的对象的内部、可访问性和[[Prototype]]属性为构造函数（指prototype.construtor所指向的构造函数）中设置的
- 执行[[Construct]]，当this关键字被提及的时候，使用新创建的对象的属性
- 返回新创建的对象（除非构造方法中返回的是‘无原型’）

### 判断是否是new调用
```js
class Parent {
  constructor() {
    if (new.target === Parent) {
      console.log( "Parent instantiated" );
    }
    else {
      console.log( "A child instantiated" );
    }
  }
}
```

## Object

### 创建对象
```js
var atom = {/* ... */};
var atom = Object.create(null);
var atom = new Foo;
var atom = Foo.call(/* ... */);
var atom = Object.setPrototypeOf(new Object, null);
```

### Object.keys
参见[Object.keys](Object.keys.md)

### Object.preventExtensions、Object.seal、Object.freeze
- http://www.cnblogs.com/snandy/p/5278474.html

### 对象删除不需要的属性
```js
const obj = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
};

const {
  a,
  b,
  ...cleanObject,
} = obj;

console.log(cleanObject);
```

### 合并对象
```js
const obj = {
  a: 1,
  b: 2,
};

const obj2 = {
  c: 3,
  d: 4,
};

const obj3 = {...obj, ...obj2};
console.log(obj3);
```

## Promise

### Promise.all
- 只要一个结果是reject就进error
```js
async function getFullPost() {
  return await Promise.all([
    fetch('/aa'),
    fetch('/bb')
  ]);
};

const [aa, bb] = getFullPost();
```

### async/await VS generator
- await会等待后面结果，再执行下面语句，如果在函数内，仅对函数内语句起阻塞作用
- async是Generator函数的语法糖。
- async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await
```js
function *foo() {
  yield 1;
  yield 2;
  yield 3;
};

var f = foo();
f.next();
// { value: 1, done: false }
// ...
```

## 函数调用模式
- 函数调用
  - foo.getName()
- 方法调用
  - getName()
- .call()
- .apply()

## iterator
- 具有Symbol.iterator属性，即是iterable

### 原生具备Iterator接口的数据结构
- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象
```js
var arr = [];
var iterator = arr[Symbol.iterator](); // { next () { ... } }
```

---

## cookie
使用注意:
1. 控制生命周期
2. 加密和安全传输技术（SSL）
3. 只存放不敏感数据
4. 分担服务端负担

缺点:
1. 早期IE，每个domain最多只能有20条cookie，每个cookie长度不能超过4KB

---

## 反模式
- 在全局上下文中定义大量的变量污染全局命名空间。
- 向setTimeout或setInterval传递字符串，无意中触发eval( )的内部使用。
- 修改Object类的原型
- 以内联形式使用Javascript，它是不可改变的。
- 在使用document.createElement等原生DOM方法更适合的情况下使用document.write

---

## Array

### Set数组去重
let arr = [1, 1, 2, 2, 3, 3];
let deduped = [...new Set(arr)];

### 字符串转数组
```js
[...`${str}`]
```

### 扁平化1层数组 flatten(array, 1)
```js
const arr = [11, [22, 33], [44, 55], 66];
const flatArr = [].concat(...arr);
```

### slice(start, end)
- 做 xxx += array.length 处理
- 做 Math.floor(Math.abs(xxxx)) 处理

---

## 递归

### 尾递归
另外一种形式
```js
function trampoline( res ) {
  while (typeof res == "function") {
    res = res();
  }
  return res;
}

var foo = (function(){
  function _foo(acc,x) {
    if (x <= 1) return acc;
    return function partial(){
      return _foo( (x / 2) + acc, x - 1 );
    };
  }

  return function(x) {
    return trampoline( _foo( 1, x ) );
  };
})();
```

- - -

## 其他
- 在 ES6 中，如果参数被省略或者值为 undefined，则取该参数的默认值
- 函数声明不可以省略函数名
- localstorage限制：pc端：5-10M，移动端：2.5M
- 控制反转是思想，依赖注入是具体实现
- 设置Error的stack层数：Error.stackTraceLimit = Infinity
- 斐波那契数：for (var f = 1; number > 1; f *= number--)
- [复制粘贴](https://mp.weixin.qq.com/s/2SFPhRVbbtMz3PatKTPF8w)
- [docker操作](https://mp.weixin.qq.com/s/McViifQcoGhI6M-n1iCXfw)
- [磁盘读写和数据库读写效率对比](https://blog.csdn.net/xiaofei0859/article/details/51147849)
  * 一次读取的内容越大，直接读文件的优势会更明显

### 类型语言
- 静态类型语言：在编译时期就检查数据类型的，所以必须在声明变量的时候指定数据类型，否则编译会不通过
- 强类型语言：变量的数据类型一旦确定下来，就不能改变了，除非经过强制类型转换

### eval
- fast path和slow path，eval运行于slow path，解析速度慢10倍
- 做代码混淆压缩时容易报错
- 难以做优化
- 不方便调试

### 赋值null和undefined
null
- 全局变量：将这个变量的指针对象以及值清空
- 对象属性：给这个属性分配了一块空的内存，垃圾回收会回收null

undefined
- 将这个对象的值清空，对象依旧存在

---

## 字节
[计算字符串所占字节数](http://www.cnblogs.com/1175429393wljblog/p/4562736.html)

### utf8和utf16
* utf8 - 变长字符编码
  - 1字节：000000 - 00007F（128个）
  - 2字节：000080 - 0007FF（1920个）
  - 3字节：000800 - 00D7FF 和 00E000 - 00FFFF（61440个）
    注：D800-DFFF 中不存在任何字符
  - 4字节：010000 - 10FFFF（1048576个）
* utf16 - 定长字符编码（其实也算变长字符）
  - 2字节：000000 – 00FFFF
  - 4字节：010000 – 10FFFF

### 拓展
Java简单数据类型中所占字符不定：
- float占用 4 字节
- double 8 字节
- byte 1字节 -128到127
- short 2 字节
- int 4 字节
- long 8 字节

---
