# 页面过程

## 参考
- https://mp.weixin.qq.com/s/LIfvU8j0gBVIFF8AYYtfFg
- http://www.dailichun.com/2018/03/12/whenyouenteraurl.html
- https://juejin.im/post/5b0b7d74518825158e173a0c
- [三次握手](https://mp.weixin.qq.com/s/yH3PzGEFopbpA-jw4MythQ)
- [chromium渲染过程](https://mp.weixin.qq.com/s/87OYpou4ynpvYlcExEO40w)
- [浏览器缓存全面处理](https://zhuanlan.zhihu.com/p/28113197)
- [chrome工作原理](https://mp.weixin.qq.com/s/X4yAFZBNLwaDUFYaR0Cn5g)


## 目录
<details>
<summary>展开更多</summary>

* [`基本原则`](#基本原则)
* [`过程简述`](#过程简述)
* [`过程详述`](#过程详述)
* [`缓存分类`](#缓存分类)
* [`流程图`](#流程图)
* [`GET vs POST`](#GETvsPOST)
* [`defer vs async`](#defervsasync)

</details>

## 基本原则
1. 任何界面系统，不论采用什么布局器，dom、css最终都是要算出一个盒子的确定（x、y、width、height）值，
    这样才能驱动图形系统去绘图，如果并行不影响这个原则，就可以并行，如果有不可预估的影响，就不能并行

## 过程简述
1. 输入URL
2. 检查缓存（请求200、强缓存200、协商缓存304）
3. DNS解析（浏览器缓存、本机缓存、hosts、路由缓存、ISP缓存、递归）
4. TCP3次握手
5. 请求，解析url，设置请求报文（头、体）
6. 服务器返回html，4次挥手
7. 浏览器渲染
  - HTML parser -> DOM Tree
  - CSS parser -> style Tree
  - DOM + style -> 渲染树render Tree
8. 布局
9. 绘制

## 过程详述
1. 在浏览器地址栏输入URL
2. 浏览器查看缓存
  - 如果请求资源在缓存中并且新鲜，跳转到15.转码步骤
  - 如果资源未缓存或服务端已更新，发起新请求（请求数据：200）
  - 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端（强缓存：200）
  - 检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control：
    - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
    - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
  - 如果通过EXpires || Cache-Control，判断已过期，则与服务器进行验证
    - 通过服务端Last-Modified && Etag判断服务端是否更新，没更新也走缓存（协商缓存：304）
    - 缓存存放，分from memory（内存）和 from disc（磁盘），有Etag才表示存磁盘
3. 浏览器解析URL获取协议，主机，端口，path
4. 浏览器组装一个HTTP（GET）请求报文
5. 浏览器DNS解析，获取主机ip地址，过程如下：
  - 浏览器缓存
  - 本机缓存
  - hosts文件
  - 路由器缓存
  - ISP DNS缓存（互联网服务提供商）
  - DNS递归查询（可能存在负载均衡导致每次IP不一样）
6. 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下：
  - 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口
  - 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包
  - 客户端发送ACK=Y+1， Seq=Z
7. TCP链接建立后发送HTTP请求
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将响应报文通过TCP连接发送回浏览器
12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次挥手如下：
  - 主动方发送Fin=1， Ack=Z， Seq= X报文
  - 被动方发送ACK=X+1， Seq=Z报文
  - 被动方发送Fin=1， ACK=X， Seq=Y报文
  - 主动方发送ACK=Y， Seq=X报文
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，进行缓存
15. 对响应进行解码（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. 关键渲染路径共分五个步骤
构建DOM -> 构建CSSOM -> 构建渲染树 -> 布局 -> 绘制
- 构建DOM树
  - bytes
  - characters
  - Tokenizing：根据HTML规范将字符流解析为标记(类似vue模板生成方式)
    - StartTag
    - EndTag
    - 边生成Token边消耗Token来生成节点对象
    - ![根据token生成dom树的过程](根据token生成节点树的过程.jpg)
  - Lexing：词法分析将标记转换为对象并定义属性和规则
  - DOM construction：根据HTML标记关系将对象组成DOM树
  - 解析过程中遇到图片、样式表、js文件，启动下载
- 构建CSSOM树
  - Tokenizing：字符流转换为标记流
  - Node：根据标记创建节点
  - CSSOM：节点创建CSSOM树
  - 与生成dom不同，需要等到cssdom构建完成才会进入下一阶段（样式层叠）
  - ![根据token生成css树的过程](根据token生成css树的过程.jpg)
- 构建渲染树
  - 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none
  - 对每一个可见节点，找到恰当的CSSOM规则并应用
  - 发布可视节点的内容和计算样式
- 布局
  - 自动重排（定位各元素在页面的确切位置和尺寸）
- 绘制
  - Paint Setup、Paint
- js解析
  - 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading
  - HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，
    并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数
    和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容
  - 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，
    但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素
  - 当文档完成解析，document.readState变成interactive
  -所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write()
  - 浏览器在Document对象上触发DOMContentLoaded事件
  - 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，
    document.readState变为complete,window触发load事件
- 知识点
  - js执行会阻塞DOM树的解析和渲染（js会涉及dom和css的操作）
  - js执行会阻塞js对DOM树的css操作（css animation不受影响）
  - css不会阻塞DOM树的解析（见webkit渲染过程）
  - css加载会阻塞DOM树渲染（浏览器优化机制）
  - css加载会阻塞js执行（渲染使用GUI进程，js执行使用v8，两者互斥）
18. 显示页面（HTML解析过程中会逐步显示页面）

## 缓存分类
- 强缓存：expires、cach-controll
- 弱缓存：last-modified、etag

## 流程图

### 缓存字段
![缓存字段](缓存字段.jpg)

### cach-control
![cachcontrol](cachcontrol.jpg)


### 网络请求统计
![网络请求统计](163a4d01fdc524f3.jpeg)

### 浏览器缓存
![浏览器缓存](163a4d01fdd197b6.jpeg)


### webkit渲染过程
![webkit渲染过程](webkit渲染过程.jpeg)

### gecko渲染过程
![gecko渲染过程](gecko渲染过程.jpg)

### 三次握手
![三次握手](gib68xrvj59.jpeg)

#### 目的
- 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

#### 概念
- syns queue（半连接队列）
- accept queue（全连接队列）
- tcp_abort_on_overflow （tcp全连接队列溢出数）0/1
  - 0：第三次全连接队列满了那么server扔掉client 发过来的ack
  - 1：第三次全连接队列满了那么server发送reset包给client

#### 过程
1. client 发送 syn 到server 发起握手
  - 此时连接信息会放到半连接队列，回复syn+ack
  - 案例-syn floods攻击：只建立syn连接，收到syn+ack后故意扔掉，导致半连接队列满，其他请求进不来
2. server 收到 syn后回复syn+ack给client
3. client 收到syn+ack后，回复server一个ack表示收到了server的syn+ack
  - 如果全连接队列没满，那么从半连接队列拿出这个连接的信息放入到全连接队列中
  - 如果全连接队列满了，如果tcp_abort_on_overflow=0，server过段时间会重发syn+ack给client，
    相当于重做第二步，如果client超时时间比较短，那就会异常

### 四次挥手
![四次挥手](201208201734418392.png)

#### 过程
- TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段4）。 
- 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。 
- 服务器关闭客户端的连接，发送一个FIN给客户端（报文段6）。 
- 客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。

### Performance API
![performance](performance.jpeg)

### chromium渲染过程
![chromium渲染过程](chromium渲染过程.jpeg)

### 字节处理

#### html
- Bytes（字节）=》Characters（字符）=》Token（标记）=》Node（）=》DOM（）

## GETvsPOST

|   | GET | POST |
| -------- | -----: | :----: |
| 后退/刷新 | 无关 | 数据被重新提交 |
| 能否收藏为书签 | √ | x |
| 能否缓存 | √ | x |
| 编码类型 | application/x-www-form-urlencoded | application/x-www-form-urlencoded/multipart/form-data |
| 参数是否保存到浏览器历史 | √ | x |
| 参数携带方式 | 请求头 | 请求头 + 请求体 |
| 数据类型限制 | ASCII | 无限制 |

*tcp链接*

### GET
1. 浏览器请求tcp连接（第一次握手）
2. 服务器答应进行tcp连接（第二次握手）
3. 浏览器确认，并发送get请求头和数据（第三次握手）
4. 服务器返回200 ok响应

### POST
1. 浏览器请求tcp连接（第一次握手）
2. 服务器答应进行tcp连接（第二次握手）
3. 浏览器确认，并发送post请求头（method、uri等）（第三次握手，这个报文比较小，
所以http会在此时进行第一次数据发送）
4. 服务器返回100 continue响应
5. 浏览器开始发送数据（body）
6. 服务器返回200 ok响应

*POST不支持管道化传输*
把需要发送到服务器上的所有请求放到输出队列中，在第一个请求
发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去

## defervsasync
* <script defer>: 异步加载，元素解析完成后执行
* <script async>: 异步加载，但执行时会阻塞元素渲染